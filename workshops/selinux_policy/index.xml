<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SELinux Policy Workshop on Red Hat | Public Sector</title>
    <link>/workshops/selinux_policy/</link>
    <description>Recent content in SELinux Policy Workshop on Red Hat | Public Sector</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/workshops/selinux_policy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Exercise 1.0 - Introduction to Security Enhanced Linux (SELinux)</title>
      <link>/workshops/selinux_policy/exercise1.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise1.0/</guid>
      <description>History In this workshop, we are going to introduce you to Security Enhanced Linux, commonly known as SELinux.&#xA;Standard Linux access policy based on the user, group, and other permissions, known as Discretionary Access Control (DAC), does not enable system administrators to create comprehensive and fine-grained security policies, such as restricting specific applications to only viewing log files, while allowing other applications to append new data to the log files.</description>
    </item>
    <item>
      <title>Exercise 1.1 - SELinux policy in RHEL</title>
      <link>/workshops/selinux_policy/exercise1.1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise1.1/</guid>
      <description>What are policies? A policy is a real-world application of SELinux controls. This chapter is an overview and examination of SELinux policy for Red Hat Enterprise Linux.&#xA;What is the Targeted Policy? The SELinux policy is highly configurable. Starting with Red Hat Enterprise Linux 5, Red Hat defaulted to the targeted policy. The goal of this policy is to lock down all processes that listen for network connections and pretty much all processes that start at boot.</description>
    </item>
    <item>
      <title>Exercise 1.2 - SELinux Contexts</title>
      <link>/workshops/selinux_policy/exercise1.2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise1.2/</guid>
      <description>Exercise Description Let’s peer under the hood a bit to see how SELinux works. All processes and files are labeled with an SELinux context; contexts contain user, role, type, and level information. This is information that SELinux needs to enforce the active policy (eg, make access decisions). But where do files and directories get their contexts?&#xA;Contexts are set when files are created, based on their parent directory’s context (with a few exceptions)</description>
    </item>
    <item>
      <title>Exercise 1.3 - Altering behavior</title>
      <link>/workshops/selinux_policy/exercise1.3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise1.3/</guid>
      <description>Exercise Description Let’s take a look at controlling SELinux behavior.&#xA;Exercise 1.3.1 Step 1: What mode are we in? Next, let’s check to see what SELinux mode your host is in:&#xA;getenforce Enforcing Step 2: Changing modes Now, we can change the mode that your host is in:&#xA;setenforce 0 getenforce Permissive And we can change it back:&#xA;setenforce 1 getenforce Enforcing Exercise 1.3.2 Booleans are if-then-else rules written in SELinux Policy.</description>
    </item>
    <item>
      <title>Exercise 1.4 - Troubleshooting</title>
      <link>/workshops/selinux_policy/exercise1.4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise1.4/</guid>
      <description>Exercise Description Let’s look at some techniques for examining SELinux, as these are useful for troubleshooting. We’ll build on this in Section 2 of the workshop.&#xA;Step 1: Changing modes for specific domains You can also set individual SELinux domains (like httpd_t, which controls web server access control) to permissve mode:&#xA;semanage permissive -a httpd_t semanage permissive -l Builtin Permissive Types Customized Permissive Types httpd_t And again, we can change it back:</description>
    </item>
    <item>
      <title>Exercise 2.0 - Creating Custom SELinux Policy</title>
      <link>/workshops/selinux_policy/exercise2.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise2.0/</guid>
      <description>Exercise Description In this exercise, we are going to download the code for the example application that we are going to write policy for, and build and install it onto our test system.&#xA;Step 1: Exit root shell If you haven’t already, exit the root shell we started in Section 1. Running whoami should not return root:&#xA;whoami ec2-user Step 2: Change directories Create a src directory, in your home directory.</description>
    </item>
    <item>
      <title>Exercise 2.1 - Generating a generic policy</title>
      <link>/workshops/selinux_policy/exercise2.1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise2.1/</guid>
      <description>Exercise Description In this exercise, we are going to automatically generate an SELinux policy framework, and learn to handle AVC messages that are generated by SELinux, when the application violates the policy.&#xA;Step 1: Generate an initial generic SELinux policy Create a policy directory, and generate an initial policy. Use sepolicy generate to generate a policy for the app that we want to enable.&#xA;cd ~/src mkdir policy cd policy sepolicy generate --init /usr/local/sbin/testapp Note the last few lines in the output from sepolicy generate:</description>
    </item>
    <item>
      <title>Exercise 2.2 - Creating a Custom SELinux Application Policy</title>
      <link>/workshops/selinux_policy/exercise2.2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise2.2/</guid>
      <description>Exercise Description This exercise will walk you through the steps required to handle AVC messages that are generated by SELinux, when an application violates existing policy. We will modify the already-created generic policy, in order to allow the application to run correctly, when we switch the policy to enforcing mode.&#xA;Step 1: Check for AVC denials Now that our app is up and running, we can check the system logs for AVC (access vector cache, where SELinux caches decisions to grant or deny access) denial messages.</description>
    </item>
    <item>
      <title>Exercise 2.3 - Creating Policy Rules for Network Access</title>
      <link>/workshops/selinux_policy/exercise2.3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise2.3/</guid>
      <description>Exercise Description In this exercise, we will continue the modification of the generic application polocy to allow network traffic to be generated by the test application. There are several rules that will be needed, to handle a variety of AVC denials.&#xA;Section 1: HTTP Port Connectivity Step 1: Check for AVC denials Let’s restart our app, to get an updated list of denials.&#xA;sudo systemctl restart testapp Let’s start with one of the denials that will be present in the audit search results, related to connecting on TCP port 80:</description>
    </item>
    <item>
      <title>Exercise 2.4 - Finishing the Policy</title>
      <link>/workshops/selinux_policy/exercise2.4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise2.4/</guid>
      <description>Exercise Description In this final exercise, we will finish the testapp SELinux policy.&#xA;Section 1: A Last-ish Interface Step 1: Check for AVC denials Let’s again restart our app, to get an updated list of denials.&#xA;sudo systemctl restart testapp We only have a few denials left, and you will see that they all (probably!) reference /etc/resolv.conf or to /etc/hosts.&#xA;sudo ausearch -m AVC -ts recent | egrep &amp;#39;^type=AVC&amp;#39; type=AVC msg=audit(1553195947.</description>
    </item>
    <item>
      <title>Exercise 2.5 - Tips &amp; Tricks</title>
      <link>/workshops/selinux_policy/exercise2.5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/exercise2.5/</guid>
      <description>Tips &amp;amp; tricks This is the conclusion of the SELinux policy workshop. Here’s some closing tips to help you work with SELinux. Please ask any questions that you have left, and thanks so much for coming!&#xA;Set a folder’s context to mimic another: mkdir -p /var/new_www/html matchpathcon /var/www/html /var/new_www/html semanage fcontext -a -e /var/www /var/new_www restorecon -Rv /var/&#xA;List ports associated with all service domains: semanage port -l&#xA;hi_reserved_port_t tcp 512-1023 hi_reserved_port_t udp 512-1023 howl_port_t tcp 5335 howl_port_t udp 5353 hplip_port_t tcp 1782, 2207, 2208, 8290, 8292, 9100, 9101, 9102, 9220, 9221, 9222, 9280, 9281, 9282, 9290, 9291, 50000, 50002 http_cache_port_t tcp 8080, 8118, 8123, 10001-10010 http_cache_port_t udp 3130 http_port_t tcp 80, 81, 443, 488, 8008, 8009, 8443 i18n_input_port_t tcp 9010 ibm_dt_2_port_t tcp 1792 ibm_dt_2_port_t udp 1792 imaze_port_t tcp 5323 imaze_port_t udp 5323 And then, add a port to an existing service’s domain, such as httpd: semanage port -a -t http_port_t -p tcp 8888</description>
    </item>
    <item>
      <title>Setup</title>
      <link>/workshops/selinux_policy/setup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/setup/</guid>
      <description>What you will learn: Cockpit (Browser-based Admin Interface) This lab provides a quick tour of the browser based admin interface client &amp;#39;Cockpit&amp;#39;. To help you get familiar with lab environment along with some key terminology we will use in subsequent lab content.&#xA;Accessing Cockpit Use this URL to access the Cockpit node, just change the workshop name (if applicable). Ask your instructor for the workshop name.&#xA;https://node-0.example.redhatgov.io:9090/system/terminal The login screen looks like this:</description>
    </item>
    <item>
      <title>Wrapup</title>
      <link>/workshops/selinux_policy/wrapup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/workshops/selinux_policy/wrapup/</guid>
      <description>That wraps up what we have planned for today. We hope you’ve learned something valuable about SELinux policies that you can apply in your daily role.&#xA;What do you think? How can we help you understand SELinux better?&#xA;Before you leave, check out the Resources below; you will find useful links that will further your SELinux education.&#xA;This Participant Guide will remain available. Please take advantage of it by creating your own SELinux policy back at your organization.</description>
    </item>
  </channel>
</rss>
