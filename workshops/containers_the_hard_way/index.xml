<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux Containers the Hard Way on Red Hat | Public Sector</title>
    <link>/workshops/containers_the_hard_way/</link>
    <description>Recent content in Linux Containers the Hard Way on Red Hat | Public Sector</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/workshops/containers_the_hard_way/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exercise 1 - The Mount Namespace</title>
      <link>/workshops/containers_the_hard_way/exercise1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/exercise1/</guid>
      <description>Exercise 1.1: Unsharing is Caring New Linux Namespaces are typically spawned by using either the clone or unshare system calls. These exist as C functions but wrappers exist in many other languages. For our purposes today, we will be using the unshare command which is ostensibly a Bash wrapper to the unshare system call.
 unshare --help   Usage: unshare [options] [&amp;lt;program&amp;gt; [&amp;lt;argument&amp;gt;...]] Run a program with some namespaces unshared from the parent.</description>
    </item>
    
    <item>
      <title>Exercise 2 - PID and IPC Namespaces</title>
      <link>/workshops/containers_the_hard_way/exercise2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/exercise2/</guid>
      <description>Exercise 2.1 - The PID Basics Before we start playing with PID namespaces, it is good to have some background on how PIDs in Linux work.
 Every process that runs on a Linux system gets a Process ID (PID). This exists as a 32-bit integer. Numbering starts at 1 and increments until there are none left. PIDs can be reused once the process terminates. If you run out of PIDs, you&amp;#8217;ll have a bad time.</description>
    </item>
    
    <item>
      <title>Exercise 3 - Network and UTS Namespaces</title>
      <link>/workshops/containers_the_hard_way/exercise3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/exercise3/</guid>
      <description>Exercise 3.1 - Network Stack Background The networking namespace in the Kernel is actually responsible for a surprisingly large number of things. It keeps tabs on all the network interfaces and their state, routing tables (Did you know there is more than one? By default, there are 4.), firewall rules, etc. All of these things are explored using the ip command. This command allows root to view and modify the networking stack.</description>
    </item>
    
    <item>
      <title>Exercise 4 - User Namespace</title>
      <link>/workshops/containers_the_hard_way/exercise4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/exercise4/</guid>
      <description>Exercise 4.1 - History Lesson The User Namespace is easily the newest namespce in the Linux Kernel. It was introduced to allow non-root users to run containers without a heavy root daemon. Typically, a non-priviledged user cannot spawn new namespaces. However, if a new User Namespace is created, then that same user can now spawn any type of namespace. Since this feature was introduced in the Kernel, you have seen newer container images come out that do not rely on daemons because they are no longer necessary.</description>
    </item>
    
    <item>
      <title>Exercise 5 - All Together Now</title>
      <link>/workshops/containers_the_hard_way/exercise5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/exercise5/</guid>
      <description>Let&amp;#8217;s put all of our new namespace skills to use! Again, we will be working as the rhel user.
 su - rhel # if neccessary unshare -mipfnuUr /bin/bash mount -t proc none /proc mount -t tmpfs none /tmp mount -t sysfs none /sys   With the call to unshare, we used all of the flags that we have used in the previous exercises. We also mounted three new filesystems after creating our sandbox.</description>
    </item>
    
    <item>
      <title>Exercise 6 - Changing the Filesystem</title>
      <link>/workshops/containers_the_hard_way/exercise6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/exercise6/</guid>
      <description>Exercise 6.1 - Some Background All of that is well and good. However, containers are great because they allow us to package and distribute software. All we&amp;#8217;ve done is isolate some Linux processes. Where&amp;#8217;s the beef?
 Containers get their root filesystem from a container image file. This is typically pulled from a registry. This file is, essentially, a TAR archive with the root filesystem contents and some metadata. Those contents are then made available to the running container through use of an Overlay Filesystem.</description>
    </item>
    
    <item>
      <title>Exercise 7 - Container Networking</title>
      <link>/workshops/containers_the_hard_way/exercise7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/exercise7/</guid>
      <description>Exercise 7.1 - Some Background The Linux Kernel provides many useful primitives that can be used to construct very intricate network configurations. They are very flexible and powerful. Of particular interest today are Virtual Ethernet Adapaters, Bridges, and Taps.
 A Virtual Ethernet Adapater operates in the Kernel exactly the way a physical NIC would. The only difference is that instead of receiving data from a physical device, a virtual adapter recieves data from another network adapter in the stack.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>/workshops/containers_the_hard_way/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/intro/</guid>
      <description>What is a container? It is a simple question without a simple answer. Search the internet for this question and you&amp;#8217;ll find an endless stream of blog posts explaining how containers differ from virtual machines. That&amp;#8217;s great, but that doesn&amp;#8217;t answer my question. What is a container? Does anybody really understand what is happening on their server what they podman run?
   By the end of this workshop, you will feel confident answering this question and explaining it to your peers.</description>
    </item>
    
    <item>
      <title>Wrapup</title>
      <link>/workshops/containers_the_hard_way/wrapup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/workshops/containers_the_hard_way/wrapup/</guid>
      <description>Wrap Up and Q&amp;amp;A That wraps up what we have planned for today.
 We explored Linux Namespaces and the unshare command in great depth. Obviously container enginers make heavy use of these namespaces. Their job is to orchestrate the namespaces, OverlayFS, image files, and active containers so you don&amp;#8217;t have to. Obviously, you wouldn&amp;#8217;t run containers this way in production, but there may be times that you&amp;#8217;d like to make use of namespaces.</description>
    </item>
    
  </channel>
</rss>